const express = require("express");
const fs = require('fs');
const path = require('path');
const sharp = require('sharp');
const sass = require('sass');
const {Client} = require("pg");
const fs_promises = require('fs/promises');

obGlobal={
    obErori:null,
    imagini:null,
    folderScss:path.join(__dirname,"resurse/sass"),
    folderCss:path.join(__dirname,"resurse/css"),
    folderBackup:path.join(__dirname,"backup"),
    categorieMare: null
}

app = express();
// setez view engine = ejs
// ejs = extensie a unui fisier care iti da flexibilitatea de a include fragmente in pagini sau js direct in html
app.set("view engine","ejs");

// folder de resurse static
app.use("/resurse", express.static(__dirname+"/resurse"));

// folderul proiectului __dirname - nu se schimba, este un macro/o constanta
// __filename - fisierul curent
// process.cwd - se poate modifica daca schimbam directorul

console.log("Folder proiect", __dirname);
console.log("Cale fisier", __filename);
console.log("Director de lucru", process.cwd());

// user bd 
var client = new Client({
    database: "bestTea",
    user: "mihai",
    password: "parola",
    host: "localhost",
    port:5432
});

client.connect();

//create the full path for the current folder to be created
vect_foldere=["temp", "temp1", "backup"]
for (let folder of vect_foldere){
    let caleFolder=path.join(__dirname, folder)
    if (!fs.existsSync(caleFolder)){
        fs.mkdirSync(caleFolder);
    }
}

//  Meniu impartirea pe categorii mari 
//  tip_produs = ceai, cafea, patiserie
client.query("select * from unnest(enum_range(null::tip_produs))", function(err, rez){
    // unnest(): This function is used to expand the array generated by enum_range into a set of rows, where each row corresponds to a single value from the enum.
    if(err)
        console.log(err);
    else{
        console.log(rez);
        obGlobal.categorieMare = rez.rows;
    }
});

//next-call the next middleware or route handler
//ce obtin din rez.rows pun in  obGlobal.categorieMare pe care il pun in res.locals.categoriemare pe care il folosesc in header.ejs linia 29 produse
//obgloobal ca sa poata sa fie vazut peste tot var globala 
// This middleware would make this list available in the template engine for every route, allowing views to easily 
// access and display these categories without needing to pass them explicitly from each route handler.
app.use("/*", function(req, res, next){
    res.locals.categorieMare = obGlobal.categorieMare;
    next();
    // next(): This function is called to pass control to the next middleware function in the stack. If you don't call next(), the request will hang, and the response will not be sent.
})

app.use(/^\/resurse(\/(\w)*)*$/, function(req,res){
    afisareEroare(res, 403);
});

app.get(["/index", "/", "/home"], async function(req, res) {
    try {
        const result = await client.query(`
            SELECT *, (CURRENT_DATE - data_adaugare <= INTERVAL '2 months') AS is_new
            FROM produse
        `);
        // The code performs a SQL query on the produse table using the database client. 
        // It selects all columns (*) and also calculates a boolean value is_new,
        //  which determines whether the product was added within the last two months.
        //  This is done by comparing the current date (CURRENT_DATE) with the data_adaugare (added date) of the product.
        
        const produse = result.rows;
        const newProducts = produse
            .filter(produs => produs.is_new)
            // Iteration: .filter() goes through each element in the array.
            // Condition Check: For each element, the arrow function produs => produs.is_new is called. This function evaluates produs.is_new.
            // Inclusion: If produs.is_new evaluates to true, the current produs object is included in the new array that .filter() creates.
            // Result: The result is a new array containing only the elements for which produs.is_new is true.
            .sort((a, b) => new Date(b.data_adaugare) - new Date(a.data_adaugare));
            // a and b elem being compared 
            // b.data_adaugare - a.data_adaugare calculates the difference between these two dates.
            // After fetching the products, it filters them to only include the new ones (is_new === true)
            // and sorts them by data_adaugare in descending order, meaning the most recent products will be at the top.
        var imagini_produse = []
        for (let prod of newProducts) {
            try {
                //  Reads the contents of a file.
                const files = await fs_promises.readdir(path.join(__dirname, "/resurse/imagini/produse", prod.imagine));
                if (files.length > 0) {
                    imagini_produse.push(path.join(files[0]));
                    // adding image paths to an array
                }
            } catch (error) {
                console.error("Failed to read directory for product image:", error);
            }
        }
    //  For each new product, the code tries to read the directory where the product images are stored.
    //  It constructs the path using the product's imagine property 
    // and reads the files in that directory. If any files are found, it stores the first one in imagini_produs

        res.render("pagini/index", {
            ip: req.ip,
            imagini: obGlobal.imagini,
            newProducts: newProducts,
            imaginiProduse: imagini_produse,
        });
    } catch (err) {
        console.error(err);
        afisareEroare(res, 2);
    }
});

app.get("/galerie", function(req, res){
    res.render("pagini/galerie" , {imagini:obGlobal.imagini});
});

app.get("/produse", async function(req, res) {
    try {
        const recomandareServire = await client.query("SELECT unnest(enum_range(null::recomandari_servire)) AS recomandare_servire");

        const additionalInfo = await client.query(`
            WITH ingredient_list AS (
                SELECT DISTINCT unnest(ingrediente) AS ingredient FROM produse
            )
            SELECT AVG(pret) AS mean_price, MIN(gramaj) AS min_gramaj, MAX(gramaj) AS max_gramaj, ARRAY(SELECT ingredient FROM ingredient_list) AS ingredients
            FROM produse
        `);

        let productsQuery = `
            SELECT *, (CURRENT_DATE - data_adaugare <= INTERVAL '2 months') AS is_new
            FROM produse
        `;
        let params = [];

        if (req.query.tip) {
            productsQuery += " WHERE categorie_mare = $1";
            // categorie_mare = $1 is used to filter rows in the database table based on a condition. The database will check each row to see if the value in the categorie_mare column matches the value provided in place of $1.
            params.push(req.query.tip);
        }

        const allProducts = await client.query(productsQuery, params);

        var imagini_prod = [];
        for (let prod of allProducts.rows) {
            try {
                const files = await fs_promises.readdir(path.join(__dirname, "/resurse/imagini/produse", prod.imagine));
                imagini_prod.push(files);
            } catch (error) {
                console.error("Failed to read directory:", error);
            }
        }

        // aici e pentru pagina cu toate produsele si e diferit de cel de mai jos,
        // care e pentru paginile doar cu anumite categorii (ceai, cafea etc)
        let minPricePerCategoryQuery = `
            SELECT DISTINCT ON (categorie_mare) *
            FROM produse
            WHERE pret IN (
                SELECT MIN(pret)
                FROM produse
                GROUP BY categorie_mare
            )
            ORDER BY categorie_mare, pret;
        `;

        if (req.query.tip) {
            // query pentru categorie
            minPricePerCategoryQuery = `
                SELECT *
                FROM produse
                WHERE categorie_mare = $1 AND pret = (
                    SELECT MIN(pret)
                    FROM produse
                    WHERE categorie_mare = $1
                    // $1 is a placeholder
                );
            `;
            params = [req.query.tip];
        }

        const minPriceProducts = await client.query(minPricePerCategoryQuery, params);

        res.render("pagini/produse", {
            // recomandare servire
            optiuni: recomandareServire.rows,
            // pret
            meanPrice: additionalInfo.rows[0].mean_price,
            // gramaj
            minGramaj: additionalInfo.rows[0].min_gramaj,
            maxGramaj: additionalInfo.rows[0].max_gramaj,
            // ingrediente
            ingredients: additionalInfo.rows[0].ingredients,
            produse: allProducts.rows,
            // 145 156
            // cerinta 9
            imagini_produse: imagini_prod,
            minPretProduse: minPriceProducts.rows
        });
    } catch (err) {
        console.error(err);
        res.status(500).send("Internal Server Error");
    }
});


// subpunctul 2 de la 6 are legatura cu produs.ejs din pagini
app.get("/produs/:id", async function(req, res) {
    try {
        const prodResult = await client.query("SELECT *, (CURRENT_DATE - data_adaugare <= INTERVAL '2 months') AS is_new FROM produse WHERE id = $1", [req.params.id]);
        let prod = prodResult.rows[0];
        if (!prod) {
            afisareEroare(res, 2);
            return;
        }

        let imagineProdCurent = null;
        try {
            const files = await fs_promises.readdir(path.join(__dirname, "/Resurse/imagini/produse", prod.imagine));
            if (files.length > 0) {
                imagineProdCurent = files[0];
            }
        } catch (error) {
            console.error("Failed to read directory:", error);
        }

        const prodSimilareResult = await client.query("SELECT * FROM produse WHERE recomandare_servire = $1 AND id != $2", [prod.recomandare_servire, prod.id]);
        const prodSimilare = prodSimilareResult.rows;

        const imagineProdRelevante = [];
        for (let simProd of prodSimilare) {
            try {
                const simFiles = await fs_promises.readdir(path.join(__dirname, "/Resurse/imagini/produse", simProd.imagine));
                if (simFiles.length > 0) {
                    imagineProdRelevante.push(simFiles[0]);
                }
            } catch (error) {
                console.error("Failed to read directory for similar products:", error);
            }
        }

        res.render("pagini/produs", {
            prod: prod,
            prodSimilare: prodSimilare,
            imagineProdCurent: imagineProdCurent,
            imaginiProdRelevante: imagineProdRelevante
        });
    } catch (err) {
        console.log(err);
        afisareEroare(res, 2);
    }
});

app.get("/favicon.ico", function(req, res){
    res.sendFile(__dirname+"/resurse/ico/favicon.ico");
});

app.get("/*.ejs",function(req, res){
    console.log("url:", req.url);
    afisareEroare(res, 400);
});

app.get("/*",function(req, res){
    res.render("pagini"+req.url, function(err, rezRandare){// callback care are ca parametri o eroare si rezultatul randarii:
                                                           // daca se intra pe cazul de eroare se afiseaza eroarea corespunzatoare; altfel, se randeaza pagina
        if(err){
            if(err.message.startsWith("Failed to lookup view")){
                afisareEroare(res, 404);
            }
            else
                afisareEroare(res);//err generica
        }
        else{
            res.send(rezRandare);
        }
    });
});

// cod irina
function initErori(){
    var continut = fs.readFileSync(__dirname+"/resurse/json/erori.json").toString("utf-8");
    obGlobal.obErori=JSON.parse(continut);
    let vErori=obGlobal.obErori.info_erori;
    for (let eroare of vErori){
        eroare.imagine=obGlobal.obErori.cale_baza+"/"+eroare.imagine;
    }
}
initErori();
// identificator nr err , imi ia titlu din fisierul json la fel si la text si imagine
function afisareEroare(res, _identificator, _titlu="Eroare", _text, _imagine){
    let vErori=obGlobal.obErori.info_erori;
    // itereaza prin vectorul de erori cu find() si atunci cand un element din vErori are identificatorul = _identificator, il returneaza (returneaza elem)
    let eroare=vErori.find(function(elem) {return elem.identificator==_identificator;})
    if(eroare){
        let titlu1 = _titlu=="Eroare" ? (eroare.titlu || _titlu) : _titlu;
        // daca _text != null -> text1 = _text, altfel o sa fie aleasa valoarea eroare.text
        let text1 = _text || eroare.text;
        let imagine1 = _imagine || eroare.imagine;
        if(eroare.status)
        // se seteaa statusul = identificatorul erorii si se randeaza pagina cu param: titlu1, text1, imagine1
        // This sets the HTTP status code of the response to the value of eroare.identificator
            res.status(eroare.identificator).render("pagini/eroare", {titlu:titlu1, text:text1, imagine:imagine1});
        else
            res.render("pagini/eroare", {titlu:titlu1, text:text1, imagine:imagine1});
    }
    else{
        let errDef=obGlobal.obErori.eroare_default;
        // titlu: errDef.titlu -> se seteaza locals.titlu = errDef.titlu si se foloseste valoarea in ejs (la client) - cand se randeaza pagina
        res.render("pagini/eroare", {titlu:errDef.titlu, text:errDef.text, imagine:obGlobal.obErori.cale_baza+"/"+errDef.imagine});
    }
}

function createImages(){
    // citeste continutul galerie.json
    var continutFisier=fs.readFileSync(__dirname+"/resurse/json/galerie.json").toString("utf8");
    // parseaza continutul intr-un obiect
    var obiect=JSON.parse(continutFisier);
    var dim_mare = 250;
    var dim_mediu = 200;
    var dim_mic = 150;
    obGlobal.imagini=obiect.imagini;

    obGlobal.imagini.forEach(function (elem){
        // este o lista care imi ia primul o data galerie1 dar si png care este extensia din galerie json 
        [numeFisier, extensie] = elem.fisier.split(".");
        //adauga cale galerie din galerie.json
        elem.fisier = obiect.cale_galerie + "/" + elem.fisier;
          //daca nu exista folder ul mare il creeaza 
        if(!fs.existsSync(__dirname+"/"+obiect.cale_galerie+"/mare/")){
            fs.mkdirSync(__dirname+"/"+obiect.cale_galerie+"/mare/");
        }
        // mai sus am folosit split ca sa ii dea remove la extensie, la nume fisier ii adauga .webp
        elem.fisier_mare=obiect.cale_galerie+"/mare/"+numeFisier+".webp";
        sharp(__dirname+"/"+elem.fisier).resize(dim_mare).toFile(__dirname+"/"+elem.fisier_mare);
        // daca nu exista documentul "/resurse/imagini/galerie" il creeaza
        if(!fs.existsSync(__dirname+"/"+obiect.cale_galerie+"/mediu/")){
            fs.mkdirSync(__dirname+"/"+obiect.cale_galerie+"/mediu/");
        }
        elem.fisier_mediu=obiect.cale_galerie+"/mediu/"+numeFisier+".webp";
        // am folosit sharp ca sa ii dau resize la fisier sa il fac mediu si dupa cale dirnmae fisier mediu care este "/resurse/imagini/galerie/mediu" 
        sharp(__dirname+"/"+elem.fisier).resize(dim_mediu).toFile(__dirname+"/"+elem.fisier_mediu);
        // daca nu exista elementul il creeaza
        if(!fs.existsSync(__dirname+"/"+obiect.cale_galerie+"/mic/")){
            fs.mkdirSync(__dirname+"/"+obiect.cale_galerie+"/mic/");
        }
        elem.fisier_mic=obiect.cale_galerie+"/mic/"+numeFisier+".webp";
        sharp(__dirname+"/"+elem.fisier).resize(dim_mic).toFile(__dirname+"/"+elem.fisier_mic);
    });
    console.log(obGlobal.imagini);
}
createImages();

function compileazaScss(caleScss, caleCss){
    console.log("cale:",caleCss);
    if(!caleCss){

        let numeFisExt=path.basename(caleScss);
        let numeFis=numeFisExt.split(".")[0]   /// "a.scss"  -> ["a","scss"]
        caleCss=numeFis+".css";
    }
    
    if (!path.isAbsolute(caleScss))
        caleScss=path.join(obGlobal.folderScss,caleScss )
    if (!path.isAbsolute(caleCss))
        caleCss=path.join(obGlobal.folderCss,caleCss )
    

    let caleBackup=path.join(obGlobal.folderBackup, "resurse/css");
    if (!fs.existsSync(caleBackup)) {
        fs.mkdirSync(caleBackup,{recursive:true})
    }
    
    // la acest punct avem cai absolute in caleScss si  caleCss

    let numeFisCss=path.basename(caleCss);
    if (fs.existsSync(caleCss)){
        fs.copyFileSync(caleCss, path.join(obGlobal.folderBackup, "resurse/css",numeFisCss ))// +(new Date()).getTime()
    }
    rez=sass.compile(caleScss, {"sourceMap":true});
    fs.writeFileSync(caleCss,rez.css)
    //console.log("Compilare SCSS",rez);
}
//compileazaScss("a.scss");
vFisiere=fs.readdirSync(obGlobal.folderScss);
for( let numeFis of vFisiere ){
    if (path.extname(numeFis)==".scss"){
        compileazaScss(numeFis);
    }
}


fs.watch(obGlobal.folderScss, function(eveniment, numeFis){
    console.log(eveniment, numeFis);
    if (eveniment=="change" || eveniment=="rename"){
        let caleCompleta=path.join(obGlobal.folderScss, numeFis);
        if (fs.existsSync(caleCompleta)){
            compileazaScss(caleCompleta);
        }
    }
})

// i am dat portul pe care sa asculte aplicatia
app.listen(8087);
console.log("Serverul a pornit");